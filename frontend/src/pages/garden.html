<!DOCTYPE html>
<html>
<head>
    <title>Ultimate Minecraft-Style Garden View</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            font-family: Arial, sans-serif;
            border-radius: 5px;
        }
        #featureIndicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-family: Arial, sans-serif;
            border: 1px solid #a8d5ba;
            display: none;
        }
        #featurePopup {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 25px;
            border-radius: 15px;
            font-family: Arial, sans-serif;
            max-width: 600px;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            display: none;
        }
        #featureTitle {
            margin: 0 0 15px 0;
            font-size: 28px;
            color: #a8d5ba;
        }
        #featureImage {
            max-width: 300px;
            display: block;
            margin: 0 auto 15px;
            border-radius: 5px;
        }
        #featureDescription {
            line-height: 1.6;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div id="instructions">
        Click to start<br>
        WASD = Move<br>
        Mouse = Look around<br>
        SPACE = Interact with nearby plant/feature<br>
        ESC = Close popup
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

<script>
let camera, scene, renderer, controls;
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();
let prevTime = performance.now();
let nearbyFeature = null;
let popupVisible = false;
let waterMesh; // For animated water

// Garden configuration
const GARDEN_CONFIG = {
    width: 120,
    depth: 120,
    blockSize: 0.8, // Even smaller for finer details
    maxHeight: 4
};

// Minecraft-style block types with enhanced subtle colors
const BLOCK_TYPES = {
    grass: { color: 0x6b8e23, height: 1 }, // Olive green
    dirt: { color: 0x5c3317, height: 1 }, // Dark brown
    stone: { color: 0x808080, height: 1 }, // Gray
    water: { color: 0x4169e1, transparent: true, opacity: 0.65, height: 0.8 }, // Royal blue
    wood: { color: 0x8b4513, height: 1 }, // Saddle brown
    leaves: { color: 0x556b2f, height: 1 }, // Dark olive green
    stem: { color: 0x228b22 }, // Forest green
    path: { color: 0xa9a9a9 }, // Dark gray for path
    fence: { color: 0x8b4513 } // Matches wood
};

// Expanded garden features for more variety
const GARDEN_FEATURES = [
    {
        title: "Rose Bush",
        description: "A vibrant rose bush with blooming flowers, symbolizing love and beauty in gardens.",
        image_url: "https://upload.wikimedia.org/wikipedia/commons/e/e6/Rosa_rubiginosa_1.jpg",
        position: { x: -25, y: 0, z: -25 },
        type: "flower",
        flower_color: 0xdb7093 // Pale violet red
    },
    {
        title: "Tulip Field",
        description: "A field of tulips in various colors, bringing springtime charm to the garden.",
        image_url: "https://upload.wikimedia.org/wikipedia/commons/1/1a/Tulip_agenensis_ZE.jpg",
        position: { x: 5, y: 0, z: 15 },
        type: "flower",
        flower_color: 0xffd700 // Gold
    },
    {
        title: "Sunflower Patch",
        description: "Tall sunflowers turning towards the sun, adding height and brightness to the landscape.",
        image_url: "https://upload.wikimedia.org/wikipedia/commons/4/40/Sunflower_sky_backdrop.jpg",
        position: { x: 25, y: 0, z: -15 },
        type: "flower",
        flower_color: 0xffa500 // Orange
    },
    {
        title: "Ancient Oak Tree",
        description: "An ancient oak tree providing shade and a sense of timeless beauty.",
        image_url: "https://upload.wikimedia.org/wikipedia/commons/a/af/Quercus_robur.jpg",
        position: { x: -15, y: 0, z: 25 },
        type: "tree"
    },
    {
        title: "Lily Pond",
        description: "A pond with lilies floating on the surface, creating a peaceful water feature.",
        image_url: "https://upload.wikimedia.org/wikipedia/commons/3/30/Lilium_candidum_1.jpg",
        position: { x: 15, y: 0, z: 5 },
        type: "flower",
        flower_color: 0xadd8e6 // Light blue
    },
    {
        title: "Garden Fountain",
        description: "A elegant stone fountain with flowing water, the heart of the garden.",
        image_url: "https://upload.wikimedia.org/wikipedia/commons/7/7e/Fountain_in_the_garden_of_the_H%C3%B4tel_Biron.jpg",
        position: { x: 0, y: 0, z: 0 },
        type: "fountain"
    },
    {
        title: "Lavender Bush",
        description: "Fragrant lavender bushes, attracting bees and adding purple hues to the garden.",
        image_url: "https://upload.wikimedia.org/wikipedia/commons/3/3f/Lavandula_angustifolia_002.jpg",
        position: { x: -5, y: 0, z: -10 },
        type: "flower",
        flower_color: 0x9370db // Medium purple
    },
    {
        title: "Birch Tree",
        description: "A slender birch tree with white bark, offering a contrast to the green foliage.",
        image_url: "https://upload.wikimedia.org/wikipedia/commons/f/fc/Betula_pendula_001.jpg",
        position: { x: 20, y: 0, z: 20 },
        type: "tree"
    }
];

// Perlin noise for terrain
const noise = new SimplexNoise();

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87cefa); // Brighter sky blue
    scene.fog = new THREE.FogExp2(0x87cefa, 0.01); // Add fog for depth and atmosphere

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 3, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true }); // Enable antialiasing for smoother look
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    controls = new THREE.PointerLockControls(camera, document.body);
    document.addEventListener('click', () => controls.lock());

    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    window.addEventListener('resize', onWindowResize);

    document.body.insertAdjacentHTML('beforeend', `
        <div id="featurePopup">
            <h2 id="featureTitle"></h2>
            <img id="featureImage" src="" />
            <div id="featureDescription"></div>
            <div style="text-align: center; margin-top: 15px; font-size: 14px; color: #888;">
                Press SPACE or ESC to close
            </div>
        </div>
    `);

    document.addEventListener('keydown', (event) => {
        if (event.code === 'Escape' && popupVisible) {
            hideFeatureDetails();
            popupVisible = false;
        }
    });

    createGarden();
    setupLighting();
    createParticles(); // Add falling leaves particles for attractiveness

    animate();
}

function createGarden() {
    createTerrain();
    createGardenFeatures();
    createPathsAndFences();
    createFountain();
}

function createTerrain() {
    const blockGeometry = new THREE.BoxGeometry(GARDEN_CONFIG.blockSize, GARDEN_CONFIG.blockSize, GARDEN_CONFIG.blockSize);

    for (let x = -GARDEN_CONFIG.width / 2; x < GARDEN_CONFIG.width / 2; x += GARDEN_CONFIG.blockSize) {
        for (let z = -GARDEN_CONFIG.depth / 2; z < GARDEN_CONFIG.depth / 2; z += GARDEN_CONFIG.blockSize) {
            // Multi-octave Perlin noise for smoother, more natural terrain
            let h = noise.noise2D(x * 0.02, z * 0.02) * 3;
            h += noise.noise2D(x * 0.04, z * 0.04) * 1.5;
            h += noise.noise2D(x * 0.08, z * 0.08) * 0.75;
            const height = Math.floor(h + 2);
            const isPond = Math.abs(x - 10) < 8 && Math.abs(z + 10) < 8;
            if (isPond) {
                const waterMaterial = new THREE.MeshStandardMaterial({
                    color: BLOCK_TYPES.water.color,
                    transparent: true,
                    opacity: BLOCK_TYPES.water.opacity
                });
                const waterBlock = new THREE.Mesh(blockGeometry, waterMaterial);
                waterBlock.position.set(x + GARDEN_CONFIG.blockSize / 2, 0.8, z + GARDEN_CONFIG.blockSize / 2);
                scene.add(waterBlock);
                const dirtMaterial = new THREE.MeshStandardMaterial({ color: BLOCK_TYPES.dirt.color });
                const dirtBlock = new THREE.Mesh(blockGeometry, dirtMaterial);
                dirtBlock.position.set(x + GARDEN_CONFIG.blockSize / 2, 0, z + GARDEN_CONFIG.blockSize / 2);
                scene.add(dirtBlock);
            } else {
                for (let y = 0; y < height; y++) {
                    const blockType = y === height - 1 ? 'grass' : 'dirt';
                    const material = new THREE.MeshStandardMaterial({ color: BLOCK_TYPES[blockType].color });
                    const block = new THREE.Mesh(blockGeometry, material);
                    block.position.set(x + GARDEN_CONFIG.blockSize / 2, y * GARDEN_CONFIG.blockSize, z + GARDEN_CONFIG.blockSize / 2);
                    block.castShadow = true;
                    block.receiveShadow = true;
                    scene.add(block);
                }
            }
        }
    }
    // Adjust feature positions to terrain height
    GARDEN_FEATURES.forEach(feature => {
        const x = feature.position.x;
        const z = feature.position.z;
        const h = noise.noise2D(x * 0.02, z * 0.02) * 3 + noise.noise2D(x * 0.04, z * 0.04) * 1.5 + noise.noise2D(x * 0.08, z * 0.08) * 0.75 + 2;
        feature.position.y = Math.floor(h) * GARDEN_CONFIG.blockSize;
    });
}

function createGardenFeatures() {
    const blockGeometry = new THREE.BoxGeometry(GARDEN_CONFIG.blockSize, GARDEN_CONFIG.blockSize, GARDEN_CONFIG.blockSize);
    const stemGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1, 8); // Cylinder for stems to look nicer
    const flowerHeadGeometry = new THREE.SphereGeometry(0.3, 8, 8); // Sphere for flower heads

    GARDEN_FEATURES.forEach(feature => {
        if (feature.type === 'tree') {
            // Tree trunk
            for (let y = 0; y < 6; y++) { // Taller trees
                const material = new THREE.MeshStandardMaterial({ color: BLOCK_TYPES.wood.color });
                const block = new THREE.Mesh(blockGeometry, material);
                block.position.set(feature.position.x, feature.position.y + y * GARDEN_CONFIG.blockSize, feature.position.z);
                block.castShadow = true;
                scene.add(block);
            }
            // Leaves with varied shape
            for (let x = -2; x <= 2; x++) {
                for (let y = 4; y <= 7; y++) {
                    for (let z = -2; z <= 2; z++) {
                        if (Math.random() > 0.25) {
                            const material = new THREE.MeshStandardMaterial({ color: BLOCK_TYPES.leaves.color });
                            const block = new THREE.Mesh(blockGeometry, material);
                            block.position.set(
                                feature.position.x + x * GARDEN_CONFIG.blockSize,
                                feature.position.y + y * GARDEN_CONFIG.blockSize,
                                feature.position.z + z * GARDEN_CONFIG.blockSize
                            );
                            block.castShadow = true;
                            scene.add(block);
                        }
                    }
                }
            }
        } else if (feature.type === 'flower') {
            // Stem
            const stemMaterial = new THREE.MeshStandardMaterial({ color: BLOCK_TYPES.stem.color });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.set(feature.position.x, feature.position.y + 0.5, feature.position.z);
            stem.castShadow = true;
            scene.add(stem);

            // Flower head
            const headMaterial = new THREE.MeshStandardMaterial({ color: feature.flower_color });
            const head = new THREE.Mesh(flowerHeadGeometry, headMaterial);
            head.position.set(feature.position.x, feature.position.y + 1, feature.position.z);
            head.castShadow = true;
            scene.add(head);
        }
    });
}

function createPathsAndFences() {
    const blockGeometry = new THREE.BoxGeometry(GARDEN_CONFIG.blockSize, 0.1, GARDEN_CONFIG.blockSize); // Flat for paths
    const fenceGeometry = new THREE.BoxGeometry(0.2, 1.2, GARDEN_CONFIG.blockSize);

    // Create winding paths
    for (let x = -30; x <= 30; x += GARDEN_CONFIG.blockSize) {
        const z = Math.sin(x * 0.1) * 5; // Winding path
        const material = new THREE.MeshStandardMaterial({ color: BLOCK_TYPES.path.color });
        const block = new THREE.Mesh(blockGeometry, material);
        block.position.set(x + GARDEN_CONFIG.blockSize / 2, 0.05, z);
        block.castShadow = true;
        block.receiveShadow = true;
        scene.add(block);
    }
    for (let z = -30; z <= 30; z += GARDEN_CONFIG.blockSize) {
        const x = Math.cos(z * 0.1) * 5; // Another winding path
        const material = new THREE.MeshStandardMaterial({ color: BLOCK_TYPES.path.color });
        block = new THREE.Mesh(blockGeometry, material);
        block.position.set(x, 0.05, z + GARDEN_CONFIG.blockSize / 2);
        block.castShadow = true;
        block.receiveShadow = true;
        scene.add(block);
    }

    // Fences with gates
    for (let x = -GARDEN_CONFIG.width / 2; x <= GARDEN_CONFIG.width / 2; x += GARDEN_CONFIG.blockSize) {
        [-(GARDEN_CONFIG.depth / 2), GARDEN_CONFIG.depth / 2].forEach(z => {
            if (Math.abs(x) > 5) { // Skip for gates
                const material = new THREE.MeshStandardMaterial({ color: BLOCK_TYPES.fence.color });
                const fence = new THREE.Mesh(fenceGeometry, material);
                fence.position.set(x + GARDEN_CONFIG.blockSize / 2, 0.6, z);
                fence.castShadow = true;
                scene.add(fence);
            }
        });
    }
    for (let z = -GARDEN_CONFIG.depth / 2; z <= GARDEN_CONFIG.depth / 2; z += GARDEN_CONFIG.blockSize) {
        [-(GARDEN_CONFIG.width / 2), GARDEN_CONFIG.width / 2].forEach(x => {
            if (Math.abs(z) > 5) {
                const material = new THREE.MeshStandardMaterial({ color: BLOCK_TYPES.fence.color });
                const fence = new THREE.Mesh(fenceGeometry, material);
                fence.rotation.y = Math.PI / 2;
                fence.position.set(x, 0.6, z + GARDEN_CONFIG.blockSize / 2);
                fence.castShadow = true;
                scene.add(fence);
            }
        });
    }
}

function createFountain() {
    const blockGeometry = new THREE.BoxGeometry(3, 0.5, 3); // Larger base
    const stoneMaterial = new THREE.MeshStandardMaterial({ color: BLOCK_TYPES.stone.color });
    const base = new THREE.Mesh(blockGeometry, stoneMaterial);
    base.position.set(0, 0.25, 0);
    scene.add(base);

    const columnGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 16);
    const column = new THREE.Mesh(columnGeometry, stoneMaterial);
    column.position.set(0, 1.25, 0);
    scene.add(column);

    const waterGeometry = new THREE.CylinderGeometry(0.4, 0.4, 1, 16);
    const waterMaterial = new THREE.MeshStandardMaterial({
        color: BLOCK_TYPES.water.color,
        transparent: true,
        opacity: BLOCK_TYPES.water.opacity
    });
    waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
    waterMesh.position.set(0, 1.75, 0);
    scene.add(waterMesh);
}

function createParticles() {
    const particleCount = 100;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const velocities = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);

    for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 1] = Math.random() * 10 + 10;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
        velocities[i * 3] = (Math.random() - 0.5) * 0.1;
        velocities[i * 3 + 1] = -Math.random() * 0.2 - 0.1;
        velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.1;
        colors[i * 3] = 0.2 + Math.random() * 0.3;
        colors[i * 3 + 1] = 0.5 + Math.random() * 0.3;
        colors[i * 3 + 2] = 0.2;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({ size: 0.2, vertexColors: true, transparent: true, opacity: 0.8 });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // Animate particles in the animate loop
    particles.userData = { velocities };
}

function setupLighting() {
    const ambient = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambient);

    const sun = new THREE.DirectionalLight(0xffdab9, 0.7);
    sun.position.set(50, 50, 50);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 2048;
    sun.shadow.mapSize.height = 2048;
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 500;
    scene.add(sun);

    // Add colorful lanterns
    const lanternColors = [0xff4500, 0xffd700, 0x32cd32, 0x1e90ff];
    const lanternPositions = [
        { x: -20, z: -20 }, { x: 20, z: -20 }, { x: -20, z: 20 }, { x: 20, z: 20 },
        { x: 0, z: -20 }, { x: 0, z: 20 }, { x: -20, z: 0 }, { x: 20, z: 0 }
    ];
    lanternPositions.forEach((pos, index) => {
        const color = lanternColors[index % lanternColors.length];
        const lanternGeometry = new THREE.SphereGeometry(0.2, 8, 8);
        const lanternMaterial = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.8 });
        const lantern = new THREE.Mesh(lanternGeometry, lanternMaterial);
        lantern.position.set(pos.x, 2, pos.z);
        scene.add(lantern);
        const light = new THREE.PointLight(color, 1, 15);
        light.position.set(pos.x, 2, pos.z);
        scene.add(light);
    });
}

function onKeyDown(event) {
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            moveForward = true;
            break;
        case 'ArrowDown':
        case 'KeyS':
            moveBackward = true;
            break;
        case 'ArrowLeft':
        case 'KeyA':
            moveLeft = true;
            break;
        case 'ArrowRight':
        case 'KeyD':
            moveRight = true;
            break;
        case 'Space':
            if (nearbyFeature && !popupVisible) {
                showFeatureDetails(nearbyFeature);
                popupVisible = true;
            } else if (popupVisible) {
                hideFeatureDetails();
                popupVisible = false;
            }
            break;
    }
}

function onKeyUp(event) {
    switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
            moveForward = false;
            break;
        case 'ArrowDown':
        case 'KeyS':
            moveBackward = false;
            break;
        case 'ArrowLeft':
        case 'KeyA':
            moveLeft = false;
            break;
        case 'ArrowRight':
        case 'KeyD':
            moveRight = false;
            break;
    }
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function checkCollision(position) {
    const PLAYER_RADIUS = 0.4;
    const WALL_MARGIN = GARDEN_CONFIG.blockSize;

    const bounds = {
        minX: -GARDEN_CONFIG.width / 2 + WALL_MARGIN,
        maxX: GARDEN_CONFIG.width / 2 - WALL_MARGIN,
        minZ: -GARDEN_CONFIG.depth / 2 + WALL_MARGIN,
        maxZ: GARDEN_CONFIG.depth / 2 - WALL_MARGIN
    };

    let newPosition = position.clone();
    let collision = false;

    if (position.x < bounds.minX) {
        newPosition.x = bounds.minX;
        collision = true;
    } else if (position.x > bounds.maxX) {
        newPosition.x = bounds.maxX;
        collision = true;
    }

    if (position.z < bounds.minZ) {
        newPosition.z = bounds.minZ;
        collision = true;
    } else if (position.z > bounds.maxZ) {
        newPosition.z = bounds.maxZ;
        collision = true;
    }

    return { collision, newPosition };
}

function updateMovement(delta) {
    if (!controls.isLocked) return;

    velocity.x -= velocity.x * 12.0 * delta; // Smoother damping
    velocity.z -= velocity.z * 12.0 * delta;

    direction.z = Number(moveForward) - Number(moveBackward);
    direction.x = Number(moveRight) - Number(moveLeft);
    direction.normalize();

    if (moveForward || moveBackward) {
        velocity.z -= direction.z * 90 * delta;
    }
    if (moveLeft || moveRight) {
        velocity.x -= direction.x * 90 * delta;
    }

    const nextPosition = camera.position.clone();
    nextPosition.x -= velocity.x * delta;
    nextPosition.z -= velocity.z * delta;

    const { collision, newPosition } = checkCollision(nextPosition);

    if (collision) {
        controls.moveRight(-velocity.x * delta * 0.5);
        controls.moveForward(-velocity.z * delta * 0.5);
    } else {
        controls.moveRight(-velocity.x * delta);
        controls.moveForward(-velocity.z * delta);
    }
}

function checkFeatureProximity() {
    const playerPosition = camera.position;
    let closestFeature = null;
    let closestDistance = 3;

    GARDEN_FEATURES.forEach(feature => {
        const featurePosition = new THREE.Vector3(
            feature.position.x,
            feature.position.y,
            feature.position.z
        );
        const distance = playerPosition.distanceTo(featurePosition);
        if (distance < closestDistance) {
            closestDistance = distance;
            closestFeature = feature;
        }
    });

    return closestFeature;
}

function showFeatureDetails(feature) {
    const popup = document.getElementById('featurePopup');
    const title = document.getElementById('featureTitle');
    const image = document.getElementById('featureImage');
    const description = document.getElementById('featureDescription');

    title.textContent = feature.title;
    image.src = feature.image_url;
    description.textContent = feature.description;

    popup.style.display = 'block';
}

function hideFeatureDetails() {
    const popup = document.getElementById('featurePopup');
    popup.style.display = 'none';
}

function updateProximityIndicator(feature) {
    let indicator = document.getElementById('featureIndicator');
    if (feature && !popupVisible) {
        const indicatorHTML = `
            <div style="font-size: 18px; margin-bottom: 5px;">${feature.title}</div>
            <div style="font-size: 14px; color: #a8d5ba;">Press SPACE to view details</div>`;
        if (!indicator) {
            indicator = document.createElement('div');
            indicator.id = 'featureIndicator';
            indicator.innerHTML = indicatorHTML;
            document.body.appendChild(indicator);
        } else {
            indicator.innerHTML = indicatorHTML;
        }
        indicator.style.display = 'block';
    } else if (indicator) {
        indicator.style.display = 'none';
    }
}

function animate() {
    requestAnimationFrame(animate);

    if (controls.isLocked) {
        const delta = Math.min((performance.now() - prevTime) / 1000, 0.1);
        nearbyFeature = checkFeatureProximity();
        updateProximityIndicator(nearbyFeature);
        updateMovement(delta);

        // Animate water in fountain
        if (waterMesh) {
            waterMesh.scale.y = 1 + Math.sin(Date.now() * 0.003) * 0.2;
        }

        // Animate particles (falling leaves)
        const particles = scene.getObjectByName('particles');
        if (particles) {
            const positions = particles.geometry.attributes.position.array;
            const velocities = particles.userData.velocities;
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] += velocities[i * 3];
                positions[i * 3 + 1] += velocities[i * 3 + 1];
                positions[i * 3 + 2] += velocities[i * 3 + 2];

                if (positions[i * 3 + 1] < 0) {
                    positions[i * 3] = (Math.random() - 0.5) * 100;
                    positions[i * 3 + 1] = Math.random() * 10 + 10;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
        }

        prevTime = performance.now();
    }

    renderer.render(scene, camera);
}

init();
</script>
</body>
</html>